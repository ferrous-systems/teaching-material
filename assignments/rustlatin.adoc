= Exercise: rustlatin
:source-language: rust

In this exercise we will implement a Rust-y, simpler variant of https://en.wikipedia.org/wiki/Pig_Latin[Pig Latin]: Depending on if a word starts with a vowel or not, either a suffix or a prefix is added to the word

== Learning Goals

You will learn how to:

* create a Rust library
* split a `&str` at specified `char`
* get single `char` out of a `&str`
* iterate over a `&str`
* define Globals
* compare a value to the content of an array
* use the Rust compiler's type inference to your advantage
* to concatenate `&str`
* return the content of a `Vec<String>` as `String`.


== Prerequisists

Todo!

== Tasks

For this exercise we define 

* the Vowels of English alphabet -> `['a', 'e', 'i', 'o', 'u']`
* a sentence is a collection of ASCII characters with words that are separated by a white space

Implement a function that splits a sentence into its words, and adds a suffix or prefix to them according to the following rules:

* If the word begins with a vowel -> add prefix “sr” to the word
* If the word does not begin with a vowel -> add suffix “rs” to the word

The function returns a `String` containing the modified words.

In order to learn as much as possible we recommend following the step-by-step solution. 

== Step-by-step-Solution
=== Getting started

Find the exercise skeletton. 

The folder contains each step as it's own numbered lib.rs file. Each file contains starter code and a test that needs to pass in order for the step to be considered complete. 

==== Rust Analyzer
A part of this exercise is seeing type inference in action and to use it to help to determine the type the funktion is going to return. To make sure the file can be indexed by Rust Analyzer, rename the file you're currently working on "lib.rs". Name it back to it's numbered version when you are finished. 





=== Step 1: Splitting a sentence and pushing its words into a vector.

Iterate over the sentence to split it into words. Use the white space as separator. Push each word into the vector `collection_of_words`. Add the correct return type to the function signature.
Run the test to see if it passes. 

.Click to see the solution
[%collapsible]
====
[source,rust]
----
fn rustlatin(sentence: &str) -> Vec<&str> {
    let mut collection_of_words = Vec::new();
    
    for word in sentence.split(' ') {
        collection_of_words.push(word);
    };
    
    collection_of_words
}
----
====

=== Step 2 Concatenating String types.

After iterating over the sentence to split it into words, add the suffix `"rs"` to each word before pushing it to the vector. To concatenate two `&str` the first needs to be turned into the owned type with `to_owned`. Then `String` and `&str` can be added using `+`. Add the correct return type to the function signature.
Run the test to see if it passes. 

.Click to see the solution
[%collapsible]
====
[source,rust]
----
fn rustlatin(sentence: &str) -> Vec<String> {
    let mut collection_of_words = Vec::new();
    
    for word in sentence.split(' ') {
        collection_of_mod_words.push(word.to_owned() + "rs")
       
    };
    collection_of_words
}
----
====

=== Step 3: Iterating over a word to return the first character.
After iterating over the sentence to split it into words, add the first character of each word to the vector. 

(Here is the info missing how people are going to learn about chars(), and how it returns an iterator and not the character, either cheat sheet, documentation or we explain it here)

Add the correct return type to the function signature.
Run the test to see if it passes. 

.Click to see the sample solution
[%collapsible]
====
[source,rust]
----
fn rustlatin(sentence: &str) -> Vec<char> {
    let mut collection_of_chars = Vec::new();
    
    for word in sentence.split(' ') {
        let first_char = word.chars().next().unwrap();
        collection_of_chars.push(first_char);
    };
    collection_of_chars
}
----
====

=== Step 4: Putting everything together: Comparing values and returning the content of the vector as `String`.

Check if the first character of each word is a vowel. Add the prefix or suffix according to the rules above. Return the content of the vector as `String`.
Run the tests to see if they pass. 

.Click to see the hints/solutions for tests
[%collapsible]
====
[source,rust]
----
fn rustlatin(sentence: &str) -> String {
    let mut collection_of_words = Vec::new();
    
    for word in sentence.split(' ') {
        let first_char = word.chars().next().unwrap();
        if VOWELS.contains(&first_char) {
            collection_of_words.push("sr".to_string() + word);
        } else {
            collection_of_words.push(word.to_string() + "rs");
        }
    };
    collection_of_words.join(" ")
}
----
====

=== Step 5 (optional)

If not already done, use functional techniques (i.e. methods on https://doc.rust-lang.org/std/iter/trait.Iterator.html[iterators]) to write the same function. Test this new function as well.

.Click to see hints/solutions for this step
[%collapsible]
====
[source,rust]
----
fn rustlatin_match(sentence: &str) -> String {
    // transform incoming words vector to rustlatined outgoing
    let new_words: Vec<_> = sentence
        .split(' ')
        .into_iter()
        .map(|word| {
            let first_char_of_word = word.chars().next().unwrap();
            if VOWELS.contains(&first_char_of_word) {
                "sr".to_string() + word
            } else {
                word.to_string() + "rs"
            }
        })
        .collect();

    new_words.join(" ")
}
----
====

