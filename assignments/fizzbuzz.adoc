= Exercise: FizzBuzz
:source-language: rust

In this exercise, we will implement our first tiny program: FizzBuzz. FizzBuzz is easy to implement, but allows for application of Rust patterns in a very clean fasion.

For completing this exercise you need to have

* basic programming skills in other languages
* the Rust Syntax Cheat Sheet

After completing this exercise you are able to

* write a simple Rust program
* create and return owned `String` s
* use conditionals
* format strings with and without printing them to the system console
* write a function with a parameter and return type. 

== Task

1. Create a new project called `fizzbuzz`
2. Define a function `fn fizzbuzz` that implements the following rules:

  * If `i` is divisible by `3`, return `String::from("Fizz")`
  * If `i` is divisible by `5`, return `String::from("Buzz")`
  * If `i` is divisible by both `3` and `5`, return `String::from("FizzBuzz")`
  * If neither of them is true return the number as a String, using `format!("{}", i)`


3. Write a main function that implements the following:
  * Iterate from `1` to `100`. 
  * On each iteration the integer is tested with `fn fizzbuzz`
  * print the returned value.

=== Step-by-Step-Solution

In general, we also recommend to use the Rust documentation to figure out things you are missing to familiarise yourself with it. If you ever feel completely stuck or that you haven't understood something, please hail the trainers quickly.

==== 1. New Project
Create a new binary Cargo project, check the build and see if it runs.

.Click to see hints/solutions for this step
[%collapsible]

[source]
----
$ cargo new fizzbuzz
$ cd fizzbuzz
$ cargo run
----


==== 2. `fn fizzbuzz`
* Create the function with the name `fizzbuzz`. It takes an unsigned 32-bit integer as an argument and returns a `String` type.

.Click to see hints/solutions for this step
[%collapsible]
[source,rust]
----
fn fizzbuzz(i: u32) -> String {
    ///....
}
----


* Creating Strings:
The two recommended ways to get a `String` type for this exercise are:
.Click to see hints/solutions for this step
[%collapsible]
[source,rust]
----
let string = String::from("Fizz");
let i = 4;
let string = i.to_string();
----

* Math operators:
* Control Flow:

[both from Rust book?]

==== 3. `fn main()`

* Counting from 1 to 100

If you have issues that your program only counts to 99, be aware that the `..`-range syntax in Rust is _end-exclusive_. Either move the bound or use the inclusive range syntax.

[source,rust]
----
for i in 1..5 { 
    // Only gives you 1, 2, 3, 4
}

for i in 1..=5 {
    // Gives you 1, 2, 3, 4 and 5
}
----

[these should be part of the cheat sheet]
=== Returning data

If you have issues returning data from multiple branches of your solution, liberally use `return`.

[source,rust]
----
if x % 5 == 0 {
    return String::from("Buzz");
}
----

=== Printing to console

The recommended way to print to the console in this exercise is `println!`. `println!` _always_ needs a format string - it uses `{}` as a placeholder to mean *print the next argument*, like Python 3 or C#.

[source,rust]
----
let s = String::from("Fizz");
println!("The value is s is {}. That's nice.", s);
----

